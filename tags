!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ARRAY_TYPE	cpp/type.h	/^    ARRAY_TYPE,$/;"	e	enum:ClassType
AST	cpp/ast.h	/^struct AST {};$/;"	s
Arguments	cpp/parser.y	/^Arguments:$/;"	l
ArrayType	cpp/parser.y	/^ArrayType:$/;"	l
ArrayType	cpp/type.h	/^struct ArrayType : Type {$/;"	s
Assignment	cpp/parser.y	/^Assignment:$/;"	l
BASIC_TYPE	cpp/type.h	/^    BASIC_TYPE,$/;"	e	enum:ClassType
BIN	Makefile	/^BIN=.\/bin$/;"	m
BUILD	Makefile	/^BUILD=.\/target\/cpp$/;"	m
BasicLit	cpp/parser.y	/^BasicLit:$/;"	l
BasicType	cpp/type.cpp	/^BasicType::BasicType(string _base) {$/;"	f	class:BasicType
BasicType	cpp/type.h	/^struct BasicType : Type {$/;"	s
BinaryOp	cpp/parser.y	/^BinaryOp:$/;"	l
Block	cpp/parser.y	/^Block:$/;"	l
BreakStmt	cpp/parser.y	/^BreakStmt:$/;"	l
CLOSEB	cpp/parser.y	/^CLOSEB:$/;"	l
CPP	Makefile	/^CPP=.\/cpp$/;"	m
Channel	cpp/parser.y	/^Channel:$/;"	l
ClassType	cpp/type.h	/^enum ClassType {$/;"	g
CompositeLit	cpp/parser.y	/^CompositeLit:$/;"	l
Condition	cpp/parser.y	/^Condition:$/;"	l
ContinueStmt	cpp/parser.y	/^ContinueStmt:$/;"	l
DOTDIR	Makefile	/^DOTDIR=.\/target\/dot$/;"	m
Data	cpp/node.cpp	/^Data::Data(string abc) {$/;"	f	class:Data
Data	cpp/node.h	/^struct Data {$/;"	s
Declaration	cpp/parser.y	/^Declaration:$/;"	l
DeferStmt	cpp/parser.y	/^DeferStmt:$/;"	l
ERROR	cpp/helpers.h	12;"	d
Element	cpp/parser.y	/^Element:$/;"	l
ElementList	cpp/parser.y	/^ElementList:$/;"	l
EmptyStmt	cpp/parser.y	/^EmptyStmt:$/;"	l
Expression	cpp/parser.y	/^Expression:$/;"	l
ExpressionList	cpp/parser.y	/^ExpressionList:$/;"	l
ExpressionStmt	cpp/parser.y	/^ExpressionStmt:$/;"	l
FLAGS	Makefile	/^FLAGS=-g -std=c++14 -Wno-write-strings -I.\/cpp$/;"	m
FUNCTION_TYPE	cpp/type.h	/^    FUNCTION_TYPE,$/;"	e	enum:ClassType
FallthroughStmt	cpp/parser.y	/^FallthroughStmt:$/;"	l
FieldDecl	cpp/parser.y	/^FieldDecl:$/;"	l
FieldDeclList	cpp/parser.y	/^FieldDeclList:$/;"	l
ForClause	cpp/parser.y	/^ForClause:$/;"	l
ForStmt	cpp/parser.y	/^ForStmt:$/;"	l
Function	cpp/parser.y	/^Function:$/;"	l
FunctionDecl	cpp/parser.y	/^FunctionDecl:$/;"	l
FunctionType	cpp/type.h	/^struct FunctionType : Type {$/;"	s
GoStmt	cpp/parser.y	/^GoStmt:$/;"	l
GotoStmt	cpp/parser.y	/^GotoStmt:$/;"	l
IdentifierList	cpp/parser.y	/^IdentifierList:$/;"	l
IfStmt	cpp/parser.y	/^IfStmt:$/;"	l
ImportDecl	cpp/parser.y	/^ImportDecl:$/;"	l
ImportDeclList	cpp/parser.y	/^ImportDeclList:$/;"	l
ImportPath	cpp/parser.y	/^ImportPath:$/;"	l
ImportSpec	cpp/parser.y	/^ImportSpec:$/;"	l
ImportSpecList	cpp/parser.y	/^ImportSpecList:$/;"	l
IncDecStmt	cpp/parser.y	/^IncDecStmt:$/;"	l
Index	cpp/parser.y	/^Index:$/;"	l
InitStmt	cpp/parser.y	/^InitStmt:$/;"	l
Key	cpp/parser.y	/^Key:$/;"	l
KeyValList	cpp/parser.y	/^KeyValList:$/;"	l
KeyedElement	cpp/parser.y	/^KeyedElement:$/;"	l
LabeledStmt	cpp/parser.y	/^LabeledStmt:$/;"	l
Literal	cpp/parser.y	/^Literal:$/;"	l
LiteralType	cpp/parser.y	/^LiteralType:$/;"	l
LiteralValue	cpp/parser.y	/^LiteralValue:$/;"	l
MakeExpr	cpp/parser.y	/^MakeExpr:$/;"	l
MapType	cpp/parser.y	/^MapType:$/;"	l
MethodDecl	cpp/parser.y	/^MethodDecl:$/;"	l
OPENB	cpp/parser.y	/^OPENB:$/;"	l
Object	cpp/operand.cpp	/^Object::Object(Object *_base) : base(_base) {$/;"	f	class:Object
Object	cpp/operand.cpp	/^Object::Object(Object *_base, bool isStar) : base(_base) {$/;"	f	class:Object
Object	cpp/operand.cpp	/^Object::Object(Object *_key, Object *_value) : key(_key), value(_value) {$/;"	f	class:Object
Object	cpp/operand.cpp	/^Object::Object(string _name) : name(_name) {$/;"	f	class:Object
Object	cpp/operand.cpp	/^Object::Object(string _name, Object *_type) {$/;"	f	class:Object
Object	cpp/operand.cpp	/^Object::Object(string _name, What _what) : name(_name) {$/;"	f	class:Object
Object	cpp/operand.cpp	/^Object::Object(unordered_map<string, Object *> _fields) : fields(_fields) {$/;"	f	class:Object
Object	cpp/operand.cpp	/^Object::Object(vector<Object *> _args, Object *_ret) : args(_args), ret(_ret) {$/;"	f	class:Object
Object	cpp/operand.cpp	/^Object::Object(vector<Object *> _types) {$/;"	f	class:Object
Operand	cpp/parser.y	/^Operand:$/;"	l
OperandName	cpp/parser.y	/^OperandName:$/;"	l
POINTER_TYPE	cpp/type.h	/^    POINTER_TYPE$/;"	e	enum:ClassType
PackageClause	cpp/parser.y	/^PackageClause:$/;"	l
ParameterDecl	cpp/parser.y	/^ParameterDecl:$/;"	l
ParameterList	cpp/parser.y	/^ParameterList:$/;"	l
Parameters	cpp/parser.y	/^Parameters:$/;"	l
PointerType	cpp/parser.y	/^PointerType:$/;"	l
PostStmt	cpp/parser.y	/^PostStmt:$/;"	l
PrimaryExpr	cpp/parser.y	/^PrimaryExpr:$/;"	l
QualifiedIdent	cpp/parser.y	/^QualifiedIdent:$/;"	l
RangeClause	cpp/parser.y	/^RangeClause:$/;"	l
Receiver	cpp/parser.y	/^Receiver:$/;"	l
Result	cpp/parser.y	/^Result:$/;"	l
ReturnStmt	cpp/parser.y	/^ReturnStmt:$/;"	l
SLICE_TYPE	cpp/type.h	/^    SLICE_TYPE,$/;"	e	enum:ClassType
STRUCT_TYPE	cpp/type.h	/^    STRUCT_TYPE,$/;"	e	enum:ClassType
Selector	cpp/parser.y	/^Selector:$/;"	l
SendStmt	cpp/parser.y	/^SendStmt:$/;"	l
ShortVarDecl	cpp/parser.y	/^ShortVarDecl:$/;"	l
Signature	cpp/parser.y	/^Signature:$/;"	l
SimpleStmt	cpp/parser.y	/^SimpleStmt:$/;"	l
Slice	cpp/parser.y	/^Slice:$/;"	l
SliceType	cpp/parser.y	/^SliceType:$/;"	l
SliceType	cpp/type.h	/^struct SliceType : Type {$/;"	s
SourceFile	cpp/parser.y	/^SourceFile:$/;"	l
Statement	cpp/parser.y	/^Statement:$/;"	l
StatementList	cpp/parser.y	/^StatementList:$/;"	l
String	cpp/parser.y	/^String:$/;"	l
StructLiteral	cpp/parser.y	/^StructLiteral:$/;"	l
StructType	cpp/parser.y	/^StructType:$/;"	l
StructType	cpp/type.h	/^struct StructType : Type {$/;"	s
TYPE	cpp/type.h	/^    TYPE,$/;"	e	enum:ClassType
TopLevelDecl	cpp/parser.y	/^TopLevelDecl:$/;"	l
TopLevelDeclList	cpp/parser.y	/^TopLevelDeclList:$/;"	l
Type	cpp/parser.y	/^Type:$/;"	l
Type	cpp/type.h	/^struct Type {$/;"	s
TypeAssertion	cpp/parser.y	/^TypeAssertion:$/;"	l
TypeClass	cpp/node.h	/^enum TypeClass {$/;"	g
TypeDecl	cpp/parser.y	/^TypeDecl:$/;"	l
TypeSpec	cpp/parser.y	/^TypeSpec:$/;"	l
UnaryExpr	cpp/parser.y	/^UnaryExpr:$/;"	l
UnaryOp	cpp/parser.y	/^UnaryOp:$/;"	l
VarDecl	cpp/parser.y	/^VarDecl:$/;"	l
VarSpec	cpp/parser.y	/^VarSpec:$/;"	l
WARN	cpp/helpers.h	13;"	d
_ArrayType	cpp/node.h	/^    _ArrayType,$/;"	e	enum:TypeClass
_BasicType	cpp/node.h	/^    _BasicType,$/;"	e	enum:TypeClass
_FunctionType	cpp/node.h	/^    _FunctionType,$/;"	e	enum:TypeClass
_HELPERS_H	cpp/helpers.h	2;"	d
_MapType	cpp/node.h	/^    _MapType,$/;"	e	enum:TypeClass
_NODE_H	cpp/node.h	2;"	d
_StarType	cpp/node.h	/^    _StarType$/;"	e	enum:TypeClass
_StructType	cpp/node.h	/^    _StructType,$/;"	e	enum:TypeClass
_TYPE_H	cpp/type.h	2;"	d
_TupleType	cpp/node.h	/^    _TupleType,$/;"	e	enum:TypeClass
argTypes	cpp/type.h	/^    vector<Type *> argTypes;$/;"	m	struct:FunctionType
base	cpp/type.h	/^    Type *base;$/;"	m	struct:ArrayType
base	cpp/type.h	/^    Type *base;$/;"	m	struct:SliceType
base	cpp/type.h	/^    string base;$/;"	m	struct:BasicType
child	cpp/node.h	/^    Data *child = NULL;$/;"	m	struct:Data
child	cpp/node.h	/^struct child {$/;"	s
children	cpp/node.h	/^    vector<child> children;$/;"	m	struct:node
classType	cpp/type.h	/^    ClassType classType = ARRAY_TYPE;$/;"	m	struct:ArrayType
classType	cpp/type.h	/^    ClassType classType = BASIC_TYPE;$/;"	m	struct:BasicType
classType	cpp/type.h	/^    ClassType classType = FUNCTION_TYPE;$/;"	m	struct:FunctionType
classType	cpp/type.h	/^    ClassType classType = SLICE_TYPE;$/;"	m	struct:SliceType
classType	cpp/type.h	/^    ClassType classType = STRUCT_TYPE;$/;"	m	struct:StructType
classType	cpp/type.h	/^    ClassType classType = TYPE;$/;"	m	struct:Type
clone	cpp/type.cpp	/^Type *ArrayType::clone() {$/;"	f	class:ArrayType
clone	cpp/type.cpp	/^Type *BasicType::clone() {$/;"	f	class:BasicType
clone	cpp/type.cpp	/^Type *FunctionType::clone() {$/;"	f	class:FunctionType
clone	cpp/type.cpp	/^Type *SliceType::clone() {$/;"	f	class:SliceType
clone	cpp/type.cpp	/^Type *StructType::clone() {$/;"	f	class:StructType
clone	cpp/type.cpp	/^Type *Type::clone() {$/;"	f	class:Type
compareList	cpp/operand.cpp	/^static bool compareList(vector<Object *> &list1, vector<Object *> &list2) {$/;"	f	file:
concat	cpp/helpers.cpp	/^char *concat(char *a, char *b) {$/;"	f
data	cpp/node.h	/^    Data *data;$/;"	m	struct:node
escape_json	cpp/helpers.cpp	/^string escape_json(const string &s) {$/;"	f
getSymType	cpp/helpers.cpp	/^Type *getSymType(string name) {$/;"	f
getType	cpp/type.cpp	/^string ArrayType::getType() {$/;"	f	class:ArrayType
getType	cpp/type.cpp	/^string BasicType::getType() {$/;"	f	class:BasicType
getType	cpp/type.cpp	/^string FunctionType::getType() {$/;"	f	class:FunctionType
getType	cpp/type.cpp	/^string SliceType::getType() {$/;"	f	class:SliceType
getType	cpp/type.cpp	/^string StructType::getType() {$/;"	f	class:StructType
getType	cpp/type.cpp	/^string Type::getType() {$/;"	f	class:Type
help	cpp/cli.cpp	/^void help() {$/;"	f
init	cpp/node.cpp	/^node &init() {$/;"	f
inittables	cpp/helpers.cpp	/^void inittables() {$/;"	f
isDefined	cpp/helpers.cpp	/^bool isDefined(string name) {$/;"	f
isInScope	cpp/helpers.cpp	/^bool isInScope(string name) {$/;"	f
isSymbol	cpp/helpers.cpp	/^bool isSymbol(string name) {$/;"	f
isType	cpp/helpers.cpp	/^bool isType(string name) {$/;"	f
isValidIdent	cpp/helpers.cpp	/^bool isValidIdent(string name) {$/;"	f
last	cpp/helpers.cpp	/^Data *last(Data *ptr) {$/;"	f
last	cpp/helpers.cpp	/^Type *last(Type *ptr) {$/;"	f
main	cpp/ast.cpp	/^int main(int argc, char **argv) {$/;"	f
main	cpp/lexer.cpp	/^int main(int argc, char **argv) {$/;"	f
main	cpp/parser.cpp	/^int main(int argc, char **argv) {$/;"	f
memNames	cpp/type.h	/^    vector<string> memNames;$/;"	m	struct:StructType
memTypes	cpp/type.h	/^    vector<Type *> memTypes;$/;"	m	struct:StructType
name	cpp/node.h	/^    string name = "";$/;"	m	struct:Data
name	cpp/node.h	/^    string name;$/;"	m	struct:node
next	cpp/node.h	/^    Data *next = NULL;$/;"	m	struct:Data
next	cpp/type.h	/^    Type *next = NULL;$/;"	m	struct:Type
node	cpp/node.h	/^struct node {$/;"	s
nt	cpp/node.h	/^    node *nt = NULL;$/;"	m	struct:child
operator +=	cpp/operand.cpp	/^Object &operator+=(Object &a, Object &b) {$/;"	f
operator <<	cpp/helpers.cpp	/^ostream &operator<<(ostream &os, Data *m) {$/;"	f
operator <<	cpp/node.cpp	/^node &operator<<(node &l, char *r) {$/;"	f
operator <<	cpp/node.cpp	/^node &operator<<(node &l, node *r) {$/;"	f
operator <<	cpp/operand.cpp	/^Object &operator<<(Object &a, Object &comp) {$/;"	f
operator <<=	cpp/operand.cpp	/^Object &operator<<=(Object &a, Object &c) {$/;"	f
operator =	cpp/operand.cpp	/^Object *Object::operator=(Object *c) {$/;"	f	class:Object
operator ==	cpp/operand.cpp	/^bool Object::operator==(Object *comp) {$/;"	f	class:Object
operator >>	cpp/node.cpp	/^node &operator>>(node &l, const char *r) {$/;"	f
operator >>	cpp/operand.cpp	/^Object *Object::operator>>(Object &comp) {$/;"	f	class:Object
parseCLI	cpp/cli.cpp	/^FILE *parseCLI(int argc, char **argv) {$/;"	f
print	cpp/helpers.cpp	/^string print(node *n) {$/;"	f
printTop	cpp/helpers.cpp	/^void printTop(node *n) {$/;"	f
printtables	cpp/helpers.cpp	/^void printtables() {$/;"	f
retTypes	cpp/type.h	/^    vector<Type *> retTypes;$/;"	m	struct:FunctionType
size	cpp/type.h	/^    int size;$/;"	m	struct:ArrayType
symInsert	cpp/helpers.cpp	/^void symInsert(string name, Type *tp) {$/;"	f
t	cpp/node.h	/^    string t = "";$/;"	m	struct:child
tostring	cpp/operand.cpp	/^string Object::tostring() {$/;"	f	class:Object
tstr	cpp/helpers.cpp	/^string tstr(char *s) {$/;"	f
type	cpp/node.h	/^    Type *type;$/;"	m	struct:node
type	cpp/node.h	/^    int type = 0;  \/\/ 0 for NT (node*), 1 for T (string)$/;"	m	struct:child
typeInsert	cpp/helpers.cpp	/^void typeInsert(string name, Type *tp) {$/;"	f
umap	cpp/node.h	9;"	d
yy_flex_debug	cpp/lexer.cpp	/^extern "C" int yy_flex_debug;$/;"	v
yydebug	cpp/ast.cpp	/^extern "C" int yydebug;$/;"	v
yydebug	cpp/lexer.cpp	/^extern "C" int yydebug;$/;"	v
yydebug	cpp/parser.cpp	/^extern "C" int yydebug;$/;"	v
yyerror	cpp/ast.cpp	/^void yyerror(const char *s) {$/;"	f
yyerror	cpp/lexer.cpp	/^void yyerror(const char *s) {$/;"	f
yyerror	cpp/parser.cpp	/^void yyerror(const char *s) {$/;"	f
yytext	cpp/lexer.cpp	/^extern "C" char *yytext;$/;"	v
